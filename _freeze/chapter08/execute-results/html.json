{
  "hash": "dd68928a0983c5e5ebd38d1cbfaf0d8e",
  "result": {
    "markdown": "---\ntitle: Vertical and horizontal transmission\nexecute:\n  freeze: auto\n---\n\n:::{.callout-note}\nThis chapter is based on \"Chapter 6: Vertical and horizontal transmission\" in @Acerbi2022.\n:::\n\n## Vertical cultural transmission {#sec-vertical}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np \nrng = np.random.default_rng()\n\nimport pandas as pd\nfrom tqdm import tqdm\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef vertical_transmission(N, p_0, b, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max): \n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # # For each generation \n        for t in range(1, t_max): \n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n\n            # randomly pick mothers and fathers\n            mother = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n            father = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n\n            # prepare next generation\n            population = pd.DataFrame({\"trait\": [np.nan] * N })\n\n            # Both parents are A, thus child adopts A\n            both_A = (mother == \"A\") & (father == \"A\")\n            # if sum(both_A) > 0:\n            population.loc[both_A,\"trait\"] = \"A\"\n\n            # Both parents are A, thus child adopts A\n            both_B = (mother == \"B\") & (father == \"B\")\n            # if sum(both_B) > 0:\n            population.loc[both_B,\"trait\"] = \"B\"\n\n            # If any empty NA slots are present (i.e. one A and one B parent) they adopt A with probability b\n            remaining = rng.choice([\"A\", \"B\"], size=population[\"trait\"].isna().sum(), replace=True, p=[b, 1 - b])\n            population.loc[population[\"trait\"].isna(),\"trait\"] = remaining\n            \n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output \n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndata_model = vertical_transmission(N=10_000, p_0=0.01, b=0.6,t_max=50, r_max=5)\n\nplot_multiple_runs(data_model)\n```\n\n::: {.cell-output .cell-output-display}\n![](chapter08_files/figure-html/cell-5-output-1.png){width=571 height=434}\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndata_model = vertical_transmission(N=10_000, p_0=0.1, b=0.5,t_max=50, r_max=5)\nplot_multiple_runs(data_model)\n```\n\n::: {.cell-output .cell-output-display}\n![](chapter08_files/figure-html/cell-6-output-1.png){width=571 height=434}\n:::\n:::\n\n\n## Horizontal cultural transmission\n\n::: {.callout-warning}\nThe code below is not yet correct and runs very slowly.\n:::\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef vertical_horizontal_transmission(N, p_0, b, n, g, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in tqdm(range(t_max)):\n            ### Vertical transmission =========================================================\n\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n\n            # randomly pick mothers and fathers\n            mother = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n            father = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n\n            # prepare next generation\n            population = pd.DataFrame({\"trait\": [np.nan] * N })\n\n            # Both parents are A, thus child adopts A\n            both_A = (mother == \"A\") & (father == \"A\")\n            # if sum(both_A) > 0:\n            population.loc[both_A,\"trait\"] = \"A\"\n\n            # Both parents are A, thus child adopts A\n            both_B = (mother == \"B\") & (father == \"B\")\n            # if sum(both_B) > 0:\n            population.loc[both_B,\"trait\"] = \"B\"\n\n            # If any empty NA slots are present (i.e. one A and one B parent) they adopt A with probability b\n            remaining = rng.choice([\"A\", \"B\"], size=population[\"trait\"].isna().sum(), replace=True, p=[b, 1 - b])\n            population.loc[population[\"trait\"].isna(),\"trait\"] = remaining\n            \n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n            ## Horizontal transmission =========================================================\n\n            previous_population = population.copy()\n            # # N_B = number of Bs\n            N_B = previous_population[previous_population[\"trait\"] == \"B\"].shape[0]\n\n            # if there are B individuals to switch, and n is not zero:\n            if (N_B > 0) & (n > 0):\n                # for each B individual:\n                for i in range(N_B):\n                    # Pick n demonstrators\n                    demonstrator = previous_population[\"trait\"].sample(n, replace=True)\n                    # Get probability g \n                    copy_ = rng.choice([True, False], n, p=[g, 1 - g], replace=True)\n                    # if any demonstrators with A are to be copied:\n                    if sum((demonstrator == \"A\") & (copy_)) > 0:\n                      # The B individual switches to A \n                      # TODO: Here's the bug!\n                      population[previous_population[\"trait\"] == \"B\"].at[i, \"trait\"] = \"A\"\n\n            next_population = population.copy()\n            # # N_B = number of Bs\n            N_B = next_population[next_population[\"trait\"] == \"B\"].shape[0]\n\n            # if there are B individuals to switch, and n is not zero:\n            if (N_B > 0) & (n > 0):\n                # for each B individual:\n                for i in range(N_B):\n                    # Pick n demonstrators\n                    demonstrator = population[\"trait\"].sample(n, replace=True)\n                    # Get probability g \n                    copy_ = rng.choice([True, False], n, p=[g, 1 - g], replace=True)\n                    # if any demonstrators with A are to be copied:\n                    if sum((demonstrator == \"A\") & (copy_)) > 0:\n                      # The B individual switches to A \n                      next_population[next_population[\"trait\"] == \"B\"].at[i, \"trait\"] = \"A\"\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = next_population[ next_population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nvertical_horizontal_transmission(N=1000, p_0=0.01, b=0.5, n=5, g=0.1, t_max=10, r_max=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>generation</th>\n      <th>p</th>\n      <th>run</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>0.003</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>0.004</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>0.006</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>3</td>\n      <td>0.007</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>4</td>\n      <td>0.010</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>5</td>\n      <td>0.015</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>6</td>\n      <td>0.018</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>7</td>\n      <td>0.020</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>8</td>\n      <td>0.022</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>9</td>\n      <td>0.021</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# data_model = vertical_horizontal_transmission(N=5_000, p_0=0.01, b=0.5, n=5, g=0.1, t_max=50, r_max=2)\n# plot_multiple_runs(data_model)\n```\n:::\n\n\n",
    "supporting": [
      "chapter08_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}